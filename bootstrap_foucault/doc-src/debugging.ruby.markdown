# Making Foucault Functional

Up till now, the bootstrapping process focused on getting the foucault system
up and running. Now it does, it is time to make a "real" program out of it.
One of the characteristics of such a real program that foucault tries to be,
is being a command line tool like any other in the UNIX userland: a program
with default behavior, options to change that default behavior, and reasonable
error reporting. In this section, we discuss these aspects.

## Making a real program out of foucault

We want foucault to behave like any other command line tool. To that end, we
add command line arguments functionality. The `optionparser` library is made
for this purpose. Following the [documentation page of
    optionparser](http://www.ruby-doc.org/stdlib/libdoc/optparse/rdoc/OptionParser.html)
    we adapt foucault, adding options. These options will be discussed in
    detail in the rest of this section.

~~~{.ruby}
#!/usr/bin/env ruby
require 'ostruct'
require 'optparse'

# Set all default options
options = OpenStruct.new
options.mirror = false
options.output_dir = ''
options.output = ''
options.debug = false

OptionParser.new do |opts|
    
    opts.banner = "Literate programming with Foucault â€” taking a narrative turn"
    opts.separator ""
    opts.separator "Usage: foucault [options] input files"
    opts.separator ""
    opts.separator "Options:"

    opts.on("-o", 
            "--output [PATH]", 
            "Path to output collected program text to") do |path|
        options.output = path
    end

    opts.on("-d", "--debug", "Generate program texts in debug mode") do |d|
        options.debug = true
    end

    opts.on_tail("-h",
                 "--help",
                 "Show this message") do
        puts opts
    end

end.parse!



document = []
ARGV.each do |input_file|
    document.concat File.readlines input_file
end
~~~

The `OpenStructure` `options` now contains all the options set by the user.

## Enabling debug mode

Foucault can collect code from fenced code blocks. It ignores all other lines
in the document. This is the default way of operating and what we want when we
generate source code from the document.

However, while programming one often makes errors. Although literate
programming is a style of programming that focusses on thinking before
programming, errors will still be a regular occurrence during programming. To
find and resolve these issues, the program code will be compiled, interpreted
of otherwise analysed and found errors will be reported on by mentioning the
place in the program text the error approximately did occur. 

The line numbers in a program text generated by foucault, however generally do
not match the line numbers of that line in the original document. To make
debugging easier, therefore, foucault should have a *debug* mode that keeps
the line numbers of the code in the document and the corresponding generated
program text the same.

The simple solution would be to make program documentation lines from all the
non-code block lines in the document. It makes looking through the generated
program code harder as the "live" code is hidden in comments. As we want to
adapt the program code in the document, not in the generated program text, it
makes more sense to just translate all non-code lines into blank lines, making
it easy to spot the code. Ideally, we would like to have tooling support that
would in the document refer to the errors in the generated program text.

~~~{.ruby}
def program_collector(document, debug = false)
    program = []

    require_relative 'lib/code_block_determinator.rb'

    line_determinator = CodeBlockDeterminator.new

    while not document.empty? do

        line = document.shift

        if line_determinator.collect_line? line
            program.push line
        elsif debug
            program.push "\n"
        else
            # ignore this line
        end

    end

    program.join
end
~~~

## Setting the output file

Foucault will output the collected program to standard out. Sometimes,
however, we want to write the program text to a file. With the `-o` or
`--output` option, the used can specify the (relative) path to that file. This
file will be overwritten if it exists and created if it does not.

~~~{.ruby}
program = program_collector document, options.debug

if not options.output.empty? then
    # try to write collected program text to file specified in options.output
    File.open(options.output, "w") do |file|
        file.puts program
    end
else
    # No output file specified: use STDOUT
    puts program
end
~~~

